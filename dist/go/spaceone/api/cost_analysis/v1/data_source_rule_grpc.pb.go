// A DataSourceRule is a resource filtering the raw data from the DataSource. The Cost resource is created after the raw data is filtered by the DataSourceRule.

// Code generated by protoc-gen-go-grpc. DO NOT EDIT.
// versions:
// - protoc-gen-go-grpc v1.4.0
// - protoc             v3.6.1
// source: spaceone/api/cost_analysis/v1/data_source_rule.proto

package v1

import (
	context "context"
	empty "github.com/golang/protobuf/ptypes/empty"
	_struct "github.com/golang/protobuf/ptypes/struct"
	grpc "google.golang.org/grpc"
	codes "google.golang.org/grpc/codes"
	status "google.golang.org/grpc/status"
)

// This is a compile-time assertion to ensure that this generated file
// is compatible with the grpc package it is being compiled against.
// Requires gRPC-Go v1.62.0 or later.
const _ = grpc.SupportPackageIsVersion8

const (
	DataSourceRule_Create_FullMethodName      = "/spaceone.api.cost_analysis.v1.DataSourceRule/create"
	DataSourceRule_Update_FullMethodName      = "/spaceone.api.cost_analysis.v1.DataSourceRule/update"
	DataSourceRule_ChangeOrder_FullMethodName = "/spaceone.api.cost_analysis.v1.DataSourceRule/change_order"
	DataSourceRule_Delete_FullMethodName      = "/spaceone.api.cost_analysis.v1.DataSourceRule/delete"
	DataSourceRule_Get_FullMethodName         = "/spaceone.api.cost_analysis.v1.DataSourceRule/get"
	DataSourceRule_List_FullMethodName        = "/spaceone.api.cost_analysis.v1.DataSourceRule/list"
	DataSourceRule_Stat_FullMethodName        = "/spaceone.api.cost_analysis.v1.DataSourceRule/stat"
)

// DataSourceRuleClient is the client API for DataSourceRule service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://pkg.go.dev/google.golang.org/grpc/?tab=doc#ClientConn.NewStream.
type DataSourceRuleClient interface {
	// Creates a new DataSourceRule. When creating the resource, this method can apply two types of conditions: mapping projects where the cost incurred to the Cost, and mapping cloud service accounts to the Cost. By adjusting the `condition_policy` parameter, the DataSourceRule can be applied when all conditions are met, applied when any of the conditions are met, or always applied regardless of whether the conditions are met.
	Create(ctx context.Context, in *CreateDataSourceRuleRequest, opts ...grpc.CallOption) (*DataSourceRuleInfo, error)
	// Updates a specific DataSourceRule. You can make changes in DataSourceRule settings, including filtering conditions. If the parameter `is_default` is `true`, only `Admin` type User can use this method.
	Update(ctx context.Context, in *UpdateDataSourceRuleRequest, opts ...grpc.CallOption) (*DataSourceRuleInfo, error)
	// Changes the priority order of the DataSourceRules to apply. If there are multiple DataSourceRules applied in a specific service account, the priority order of the resources is requried. This method changes the priority order to apply DataSourceRules.
	ChangeOrder(ctx context.Context, in *ChangeDataSourceRuleOrderRequest, opts ...grpc.CallOption) (*DataSourceRuleInfo, error)
	// Deletes a specific DataSourceRule. You must specify the `data_source_rule_id` of the DataSourceRule to delete. If the parameter `is_default` is `true`, only `Admin` type User can use this method.
	Delete(ctx context.Context, in *DataSourceRuleRequest, opts ...grpc.CallOption) (*empty.Empty, error)
	// Gets a specific DataSourceRule. Prints detailed information about the DataSourceRule, including  `conditions_policy` and conditions applied to DataSources.
	Get(ctx context.Context, in *DataSourceRuleRequest, opts ...grpc.CallOption) (*DataSourceRuleInfo, error)
	// Gets a list of all DataSourceRules. You can use a query to get a filtered list of DataSourceRules.
	List(ctx context.Context, in *DataSourceRuleQuery, opts ...grpc.CallOption) (*DataSourceRulesInfo, error)
	Stat(ctx context.Context, in *DataSourceRuleStatQuery, opts ...grpc.CallOption) (*_struct.Struct, error)
}

type dataSourceRuleClient struct {
	cc grpc.ClientConnInterface
}

func NewDataSourceRuleClient(cc grpc.ClientConnInterface) DataSourceRuleClient {
	return &dataSourceRuleClient{cc}
}

func (c *dataSourceRuleClient) Create(ctx context.Context, in *CreateDataSourceRuleRequest, opts ...grpc.CallOption) (*DataSourceRuleInfo, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(DataSourceRuleInfo)
	err := c.cc.Invoke(ctx, DataSourceRule_Create_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *dataSourceRuleClient) Update(ctx context.Context, in *UpdateDataSourceRuleRequest, opts ...grpc.CallOption) (*DataSourceRuleInfo, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(DataSourceRuleInfo)
	err := c.cc.Invoke(ctx, DataSourceRule_Update_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *dataSourceRuleClient) ChangeOrder(ctx context.Context, in *ChangeDataSourceRuleOrderRequest, opts ...grpc.CallOption) (*DataSourceRuleInfo, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(DataSourceRuleInfo)
	err := c.cc.Invoke(ctx, DataSourceRule_ChangeOrder_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *dataSourceRuleClient) Delete(ctx context.Context, in *DataSourceRuleRequest, opts ...grpc.CallOption) (*empty.Empty, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(empty.Empty)
	err := c.cc.Invoke(ctx, DataSourceRule_Delete_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *dataSourceRuleClient) Get(ctx context.Context, in *DataSourceRuleRequest, opts ...grpc.CallOption) (*DataSourceRuleInfo, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(DataSourceRuleInfo)
	err := c.cc.Invoke(ctx, DataSourceRule_Get_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *dataSourceRuleClient) List(ctx context.Context, in *DataSourceRuleQuery, opts ...grpc.CallOption) (*DataSourceRulesInfo, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(DataSourceRulesInfo)
	err := c.cc.Invoke(ctx, DataSourceRule_List_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *dataSourceRuleClient) Stat(ctx context.Context, in *DataSourceRuleStatQuery, opts ...grpc.CallOption) (*_struct.Struct, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(_struct.Struct)
	err := c.cc.Invoke(ctx, DataSourceRule_Stat_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// DataSourceRuleServer is the server API for DataSourceRule service.
// All implementations must embed UnimplementedDataSourceRuleServer
// for forward compatibility
type DataSourceRuleServer interface {
	// Creates a new DataSourceRule. When creating the resource, this method can apply two types of conditions: mapping projects where the cost incurred to the Cost, and mapping cloud service accounts to the Cost. By adjusting the `condition_policy` parameter, the DataSourceRule can be applied when all conditions are met, applied when any of the conditions are met, or always applied regardless of whether the conditions are met.
	Create(context.Context, *CreateDataSourceRuleRequest) (*DataSourceRuleInfo, error)
	// Updates a specific DataSourceRule. You can make changes in DataSourceRule settings, including filtering conditions. If the parameter `is_default` is `true`, only `Admin` type User can use this method.
	Update(context.Context, *UpdateDataSourceRuleRequest) (*DataSourceRuleInfo, error)
	// Changes the priority order of the DataSourceRules to apply. If there are multiple DataSourceRules applied in a specific service account, the priority order of the resources is requried. This method changes the priority order to apply DataSourceRules.
	ChangeOrder(context.Context, *ChangeDataSourceRuleOrderRequest) (*DataSourceRuleInfo, error)
	// Deletes a specific DataSourceRule. You must specify the `data_source_rule_id` of the DataSourceRule to delete. If the parameter `is_default` is `true`, only `Admin` type User can use this method.
	Delete(context.Context, *DataSourceRuleRequest) (*empty.Empty, error)
	// Gets a specific DataSourceRule. Prints detailed information about the DataSourceRule, including  `conditions_policy` and conditions applied to DataSources.
	Get(context.Context, *DataSourceRuleRequest) (*DataSourceRuleInfo, error)
	// Gets a list of all DataSourceRules. You can use a query to get a filtered list of DataSourceRules.
	List(context.Context, *DataSourceRuleQuery) (*DataSourceRulesInfo, error)
	Stat(context.Context, *DataSourceRuleStatQuery) (*_struct.Struct, error)
	mustEmbedUnimplementedDataSourceRuleServer()
}

// UnimplementedDataSourceRuleServer must be embedded to have forward compatible implementations.
type UnimplementedDataSourceRuleServer struct {
}

func (UnimplementedDataSourceRuleServer) Create(context.Context, *CreateDataSourceRuleRequest) (*DataSourceRuleInfo, error) {
	return nil, status.Errorf(codes.Unimplemented, "method Create not implemented")
}
func (UnimplementedDataSourceRuleServer) Update(context.Context, *UpdateDataSourceRuleRequest) (*DataSourceRuleInfo, error) {
	return nil, status.Errorf(codes.Unimplemented, "method Update not implemented")
}
func (UnimplementedDataSourceRuleServer) ChangeOrder(context.Context, *ChangeDataSourceRuleOrderRequest) (*DataSourceRuleInfo, error) {
	return nil, status.Errorf(codes.Unimplemented, "method ChangeOrder not implemented")
}
func (UnimplementedDataSourceRuleServer) Delete(context.Context, *DataSourceRuleRequest) (*empty.Empty, error) {
	return nil, status.Errorf(codes.Unimplemented, "method Delete not implemented")
}
func (UnimplementedDataSourceRuleServer) Get(context.Context, *DataSourceRuleRequest) (*DataSourceRuleInfo, error) {
	return nil, status.Errorf(codes.Unimplemented, "method Get not implemented")
}
func (UnimplementedDataSourceRuleServer) List(context.Context, *DataSourceRuleQuery) (*DataSourceRulesInfo, error) {
	return nil, status.Errorf(codes.Unimplemented, "method List not implemented")
}
func (UnimplementedDataSourceRuleServer) Stat(context.Context, *DataSourceRuleStatQuery) (*_struct.Struct, error) {
	return nil, status.Errorf(codes.Unimplemented, "method Stat not implemented")
}
func (UnimplementedDataSourceRuleServer) mustEmbedUnimplementedDataSourceRuleServer() {}

// UnsafeDataSourceRuleServer may be embedded to opt out of forward compatibility for this service.
// Use of this interface is not recommended, as added methods to DataSourceRuleServer will
// result in compilation errors.
type UnsafeDataSourceRuleServer interface {
	mustEmbedUnimplementedDataSourceRuleServer()
}

func RegisterDataSourceRuleServer(s grpc.ServiceRegistrar, srv DataSourceRuleServer) {
	s.RegisterService(&DataSourceRule_ServiceDesc, srv)
}

func _DataSourceRule_Create_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(CreateDataSourceRuleRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(DataSourceRuleServer).Create(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: DataSourceRule_Create_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(DataSourceRuleServer).Create(ctx, req.(*CreateDataSourceRuleRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _DataSourceRule_Update_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(UpdateDataSourceRuleRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(DataSourceRuleServer).Update(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: DataSourceRule_Update_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(DataSourceRuleServer).Update(ctx, req.(*UpdateDataSourceRuleRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _DataSourceRule_ChangeOrder_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ChangeDataSourceRuleOrderRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(DataSourceRuleServer).ChangeOrder(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: DataSourceRule_ChangeOrder_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(DataSourceRuleServer).ChangeOrder(ctx, req.(*ChangeDataSourceRuleOrderRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _DataSourceRule_Delete_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(DataSourceRuleRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(DataSourceRuleServer).Delete(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: DataSourceRule_Delete_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(DataSourceRuleServer).Delete(ctx, req.(*DataSourceRuleRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _DataSourceRule_Get_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(DataSourceRuleRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(DataSourceRuleServer).Get(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: DataSourceRule_Get_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(DataSourceRuleServer).Get(ctx, req.(*DataSourceRuleRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _DataSourceRule_List_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(DataSourceRuleQuery)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(DataSourceRuleServer).List(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: DataSourceRule_List_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(DataSourceRuleServer).List(ctx, req.(*DataSourceRuleQuery))
	}
	return interceptor(ctx, in, info, handler)
}

func _DataSourceRule_Stat_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(DataSourceRuleStatQuery)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(DataSourceRuleServer).Stat(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: DataSourceRule_Stat_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(DataSourceRuleServer).Stat(ctx, req.(*DataSourceRuleStatQuery))
	}
	return interceptor(ctx, in, info, handler)
}

// DataSourceRule_ServiceDesc is the grpc.ServiceDesc for DataSourceRule service.
// It's only intended for direct use with grpc.RegisterService,
// and not to be introspected or modified (even as a copy)
var DataSourceRule_ServiceDesc = grpc.ServiceDesc{
	ServiceName: "spaceone.api.cost_analysis.v1.DataSourceRule",
	HandlerType: (*DataSourceRuleServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "create",
			Handler:    _DataSourceRule_Create_Handler,
		},
		{
			MethodName: "update",
			Handler:    _DataSourceRule_Update_Handler,
		},
		{
			MethodName: "change_order",
			Handler:    _DataSourceRule_ChangeOrder_Handler,
		},
		{
			MethodName: "delete",
			Handler:    _DataSourceRule_Delete_Handler,
		},
		{
			MethodName: "get",
			Handler:    _DataSourceRule_Get_Handler,
		},
		{
			MethodName: "list",
			Handler:    _DataSourceRule_List_Handler,
		},
		{
			MethodName: "stat",
			Handler:    _DataSourceRule_Stat_Handler,
		},
	},
	Streams:  []grpc.StreamDesc{},
	Metadata: "spaceone/api/cost_analysis/v1/data_source_rule.proto",
}
